// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.1
// source: auth.proto

/* eslint-disable */
import type { handleUnaryCall, UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { AuthTokens, Empty } from "./common";

export const protobufPackage = "squirrel.auth.v1";

export interface RegisterRequest {
  email: string;
  password: string;
  displayName: string;
  workspaceName: string;
}

export interface LoginRequest {
  email: string;
  password: string;
  totpCode: string;
}

export interface RefreshRequest {
  refreshToken: string;
}

export interface ProfileResponse {
  id: string;
  email: string;
  displayName: string;
  role: string;
}

export const SQUIRREL_AUTH_V1_PACKAGE_NAME = "squirrel.auth.v1";

function createBaseRegisterRequest(): RegisterRequest {
  return { email: "", password: "", displayName: "", workspaceName: "" };
}

export const RegisterRequest = {
  encode(message: RegisterRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.workspaceName !== "") {
      writer.uint32(34).string(message.workspaceName);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.workspaceName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { email: "", password: "", totpCode: "" };
}

export const LoginRequest = {
  encode(message: LoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.totpCode !== "") {
      writer.uint32(26).string(message.totpCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.totpCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRefreshRequest(): RefreshRequest {
  return { refreshToken: "" };
}

export const RefreshRequest = {
  encode(message: RefreshRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RefreshRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseProfileResponse(): ProfileResponse {
  return { id: "", email: "", displayName: "", role: "" };
}

export const ProfileResponse = {
  encode(message: ProfileResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ProfileResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface AuthServiceClient {
  register(request: RegisterRequest): Observable<AuthTokens>;

  login(request: LoginRequest): Observable<AuthTokens>;

  refresh(request: RefreshRequest): Observable<AuthTokens>;

  profile(request: Empty): Observable<ProfileResponse>;
}

export interface AuthServiceController {
  register(request: RegisterRequest): Promise<AuthTokens> | Observable<AuthTokens> | AuthTokens;

  login(request: LoginRequest): Promise<AuthTokens> | Observable<AuthTokens> | AuthTokens;

  refresh(request: RefreshRequest): Promise<AuthTokens> | Observable<AuthTokens> | AuthTokens;

  profile(request: Empty): Promise<ProfileResponse> | Observable<ProfileResponse> | ProfileResponse;
}

export function AuthServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["register", "login", "refresh", "profile"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const AUTH_SERVICE_NAME = "AuthService";

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  register: {
    path: "/squirrel.auth.v1.AuthService/Register",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterRequest) => Buffer.from(RegisterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterRequest.decode(value),
    responseSerialize: (value: AuthTokens) => Buffer.from(AuthTokens.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthTokens.decode(value),
  },
  login: {
    path: "/squirrel.auth.v1.AuthService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest) => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginRequest.decode(value),
    responseSerialize: (value: AuthTokens) => Buffer.from(AuthTokens.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthTokens.decode(value),
  },
  refresh: {
    path: "/squirrel.auth.v1.AuthService/Refresh",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshRequest) => Buffer.from(RefreshRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RefreshRequest.decode(value),
    responseSerialize: (value: AuthTokens) => Buffer.from(AuthTokens.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthTokens.decode(value),
  },
  profile: {
    path: "/squirrel.auth.v1.AuthService/Profile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Empty.decode(value),
    responseSerialize: (value: ProfileResponse) => Buffer.from(ProfileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ProfileResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  register: handleUnaryCall<RegisterRequest, AuthTokens>;
  login: handleUnaryCall<LoginRequest, AuthTokens>;
  refresh: handleUnaryCall<RefreshRequest, AuthTokens>;
  profile: handleUnaryCall<Empty, ProfileResponse>;
}
